# 多线程调用

Java 中 JVM 允许程序运行多个线程，使用 java.lang.Thread 类代表 线程，所有的线程对象都必须是 Thread 类或子类的实例。

Thread 类的特点：

- 每个线程都必须通过 Thread 对象的 `run()` 方法来完成执行，因此 `run()` 也叫做 **线程执行体**；
- 线程需要通过 Thread 对象的 `start()` 方法来启动该线程，而非直接调用 `run()` 方法；
- 想要实现多线程，必须在主线程（main方法）中创建新的线程对象，而非多次调用 `start()` ；



## 创建线程的方式

### 继承 Thread 类

通过继承 Thread 类来 **创建** 并 **启动多线程** ：

```java
class PrintfNumber extends Thread {
  	// 为当前线程指定名称
    public PrintfNumber(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "hello");
    }
}
```

```java
public static void main(String[] args) {
  	PrintfNumber p1 = new PrintfNumber("Thread1");
	p1.start();
}
```

其中 `mian()` 方法可以理解为主线程，而自定义的 PrintfNumber 就是一个分线程，运行在主线程中。

**匿名线程** 是 Java 中一种特殊的线程创建方式，它不需要显式地定义一个线程类，而是直接在需要的地方创建一个线程对象。

```java
new Thread() {
    @Override
    public void run() {
        System.out.println("Hello from anonymous thread!");
    }
}.start();
```



### 实现 Runnable 接口

Java 中有单继承的显示，第一种方式当我们继承了 Thread 类时，就无法继承其他类了。

Java 核心类库中提供了 `Runnable` 接口，我们可以继承 `Runnable` 接口，重写 `run()` 方法，从而实现多线程。

```java
class EvenNumberThread implements Runnable {
    @Override
    public void run() {
		System.out.println(Thread.currentThread().getName() + ":" + i);
    }
}
```

```java
EvenNumberThread e = new EvenNumberThread();
new Thread(e).start();
```

变形写法：

```java
new Thread(new Runnable() {
    @Override
    public void run() {
		System.out.println(Thread.currentThread().getName() + ":" + i);
    }
}).start();

new Thread("thread") {
    @Override
    public void run() {
        System.out.println(getName() + "hello world");
    }
}.start();
```



::: info 总结

实现 Runnable 接口比继承 Thread 类所具有的优势：

- 避免了单继承的局限性；
- 多个线程可以共享同一个接口实现类的对象，适合多个相同线程处理同一份数据的情况；

:::



## 线程常用方法

| 方法            | 描述                                                         | 是否需要抛异常 |
| --------------- | ------------------------------------------------------------ | -------------- |
| currentThread() | 获取当前执行代码的线程                                       |                |
| getName()       | 获取当前线程的名字                                           |                |
| setName()       | 设置当前线程的名字                                           |                |
| sleep(1000)     | 使线程睡眠指定的时长（单位：毫秒）                           | 是             |
| yield()         | 执行该方法，表示当前线程将释放CPU的执行权                    | 是             |
| join()          | 子线程调用该方法，表示主线程会阻塞，直到子线程执行完成后，主线程再执行 | 是             |
| isAlive()       | 判断当前线程是否存活                                         |                |

::: code-group

```java [yield()] {13}
public class yieldTest {
    public static void main(String[] args) {
        EvenNumber1 e1 = new EvenNumber1();
        e1.start();

        for (int i = 1; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + "===>" + i);
            }

            if (i % 20 == 0) {
                // 主线程释放CPU执行权，让子线程优先执行
                Thread.yield();
            }
        }
    }
}

class EvenNumber1 extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}
```

```java [join()] {14,21}
public class JoinTest {
    public static void main(String[] args) {
        EvenNumber2 e2 = new EvenNumber2();
        e2.start();

        for (int i = 1; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }

            if (i % 20 == 0) {
                try {
                    // 当主线程执行到20时，主线程将阻塞，把运行权给到分线程，当分线程执行完成后主线程再执行
                    e2.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        // 查看子线程是都存活
        System.out.println("Thread-0的声明周期：" + e2.isAlive());
    }
}

class EvenNumber2 extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}
```

:::



## 线程优先级

每个线程都有一定的优先级，相同优先级的线程使用 **分时调度策略**，优先级高的线程采用 **抢占式策略**，获得较多的执行机会。

设置线程优先级方法：

| 方法          | 描述                                      |
| ------------- | ----------------------------------------- |
| getPriority() | 返回当前线程优先级                        |
| setPriority() | 设置当前线程优先级，取值范围 [1, 10] 之间 |

Java 自带的线程优先级常量：

| 常量          | 描述             |
| ------------- | ---------------- |
| MIN_PRIORITY  | 1，最小线程级别  |
| NORM_PRIORITY | 5，默认线程级别  |
| MAX_PRIORITY  | 10，最大线程级别 |

```java {5,9,12,13,24,25}
public class PriorityTest {
    public static void main(String[] args) {
        EvenNumber4 e4 = new EvenNumber4();
        //为e4子线程设置最大线程级别
        e4.setPriority(Thread.MAX_PRIORITY);
        e4.start();

        //为main主线程，设置最小线程级别
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        for (int i = 1; i <= 100; i++) {
            if (i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + ":" +
                        Thread.currentThread().getPriority() + ":" + i);
            }
        }
    }
}

class EvenNumber4 extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName() + ":" +
                        Thread.currentThread().getPriority() + ":" + i);
            }
        }
    }
}
```
