# 线程安全

## 线程生命周期

![image-20240814194633881](./assets/线程生命周期.png)

- NEW（新建）：线程刚被创建，但是并未启动，即还没有调用 `start()`；

- RUNNABLE（可运行）：线程处于可运行状态，只有获得了 CPU 时间片的线程才能执行；

- TEMINATED（被中止）：表明程序已经结束生命周期，终止运行；

- 阻塞状态：

  - BLOCKED（锁阻塞）：一个正在阻塞，等待一个监视器锁的线程处于该状态。只有获得锁对象的线程才能有执行机会。

    >例如，A线程和B线程使用同一个锁，如果A线程获取到了锁，那么A线程就进入到 Runnable 状态，B线程就进入到了 Bloaked 阻塞状态。

  - TIMED_WAITING（计时状态）：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于该状态。

  - WAITING（无限等待）：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于该状态。

  

## 线程安全

线程安全 是指多个线程访问同一个**共享数据**时，不会因为同时操作而导致数据的不一致或者程序出错。

>就如同 5 个人同时上厕所，必须要等到前一个上完之后，后一个人才可以上。



### 同步代码块

`synchronized` 关键字可以确保同一时刻只能有一个线程访问它修饰的代码块或方法。

语法：

::: danger 注意

1. 同步监视器 可以是任意的类，但是必须是唯一的类；
2. 继承自 `Thread` 的线程，可以使用 `类.class` 作为 同步监视器（锁）；
3. 实现了 `Runnable` 接口的线程，可以使用 `类.class` 或 `this` 作为 同步监视器（锁）；

:::

```java
synchronized (同步监视器) {
  // 需要同步的代码
}
```



示例：

:::code-group

```java [继承Thread类] {7}
class window extends Thread {
  private static int tickets = 100;

  @Override
  public void run() {
    while (true) {
      synchronized (window.class) {
        // 同步代码
      }
    }
  }
}
```

```java [实现Runnable接口] {7}
class window1 implements Runnable {
  private int tickets = 100;

  @Override
  public void run() {
    while (true) {
      synchronized (this) {
        // 同步代码
      }
    }
  }
}
```

:::



### 同步方法

:::danger

1. 继承自 `Thread` 的线程，使用同步方法时需要注意，因为默认的同步监视器是 this，当有多个实例时，this 指向会有多个，无法解决线程安全；
2. 当然，如果类内方法允许，可以设置为 `static` 静态的方法；
3. 实现了 `Runnable` 接口的线程，直接使用 同步方法 解决线程安全，因为它的默认同步监视器 `this` 是唯一的；

:::

```java
public synchronized void method() {
  // 方法体
}
```



示例：

::: code-group

```java [实现Runnable接口]
class window2 implements Runnable {
	@Override
  public void run() {
		show();
  }

  /**
   * synchronized 修饰该方法，默认的同步监视器就是 this，它是唯一的
   */
  public synchronized void show() {
  }
}
```

```java [继承Thread类]
class window3 extends Thread {
  @Override
  public void run() {
  }

  /**
   * 不加 static，默认的同步监视器就是this，而这里的this指向的是创建的类的实例，它不唯一
   */
  public static synchronized void show() {
  }
}
```

:::

::: info synchronized的优缺点

优点：

- 使用了同步监视器，确保了线程的安全性。

缺点：

- `synchronized` 在操作数据时，实际上是串行执行的，一个线程修改其他线程只能等待，效率比较低。

::: 



## 死锁

不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了死锁。

>一旦出现了死锁，整个程序不会发生异常，也不会报错，只是线程处于阻塞状态，无法继续。

![image-20240819223706032](./assets/互斥锁.png)

::: detail 死锁案例

```java
public static void main(String[] args) {
  StringBuilder s1 = new StringBuilder();
  StringBuilder s2 = new StringBuilder();

  new Thread() {
    @Override
    public void run() {
      synchronized (s1) {
        s1.append("a");
        s2.append("1");

        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }

        synchronized (s2) {
          s1.append("b");
          s2.append("2");
          System.out.println(s1);
          System.out.println(s2);
        }
      }

    }
  }.start();

  new Thread() {
    @Override
    public void run() {
      synchronized (s2) {
        s1.append("c");
        s2.append("3");

        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }

        synchronized (s1) {
          s1.append("d");
          s2.append("4");

          System.out.println(s1);
          System.out.println(s2);
        }
      }
    }
  }.start();
}
```

:::



**诱发死锁的原因及解决方案：**

| 死锁原因   | 解决方案                                                     |
| ---------- | ------------------------------------------------------------ |
| 互斥条件   | 互斥条件基本无法解决，不互斥也就不存在死锁问题了             |
| 占用且等待 | 可以考虑让线程一次性占有所有资源，这样就不存在等待的问题     |
| 不可抢夺   | 占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放已经占用的资源 |
| 循环等待   | 可以将资源改为线性顺序，所有的线程按照一定顺序有序的使用资源 |



## Lock锁

Lock锁 位于java.util.concurrent.locks.Lock接口中，该接口是控制多个线程对共享资源进行访问的工具。

Lock锁也称同步锁，它的使用方法：

```java {6,11}
class A {
  private static final ReentrantLock lock = new ReentrantLock();
  
  public void method() {
    // 加同步锁
    lock.lock();
    try {
      // 同步代码
    } finally {
      // 释放同步锁
      lock.unlock(); 
    }
  }
}
```

::: info synchronized 和 lock 锁的对比

1. Lock是显式锁，需要手动加锁和释放锁，synchronized 是隐式锁，除了作用域、遇到异常时自动释放锁；
2. 使用 Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且 Lock锁有更好的可扩展性，例如读锁、写锁、读写锁等；

:::











































































