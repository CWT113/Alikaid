# 线程安全

## 线程生命周期

![image-20240814194633881](./assets/线程生命周期.png)

- NEW（新建）：线程刚被创建，但是并未启动，即还没有调用 `start()`；

- RUNNABLE（可运行）：线程处于可运行状态，只有获得了 CPU 时间片的线程才能执行；

- TEMINATED（被中止）：表明程序已经结束生命周期，终止运行；

- 阻塞状态：

  - BLOCKED（锁阻塞）：一个正在阻塞，等待一个监视器锁的线程处于该状态。只有获得锁对象的线程才能有执行机会。

    >例如，A线程和B线程使用同一个锁，如果A线程获取到了锁，那么A线程就进入到 Runnable 状态，B线程就进入到了 Bloaked 阻塞状态。

  - TIMED_WAITING（计时状态）：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于该状态。

  - WAITING（无限等待）：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于该状态。

  

## 线程安全

线程安全 是指多个线程访问同一个**共享数据**时，不会因为同时操作而导致数据的不一致或者程序出错。

>就如同 5 个人同时上厕所，必须要等到前一个上完之后，后一个人才可以上。



### 同步代码块

`synchronized` 关键字可以确保同一时刻只能有一个线程访问它修饰的代码块或方法。

语法：

::: danger 注意

1. 同步监视器 可以是任意的类，但是必须是唯一的类；
2. 继承自 `Thread` 的线程，可以使用 `类.class` 作为 同步监视器（锁）；
3. 实现了 `Runnable` 接口的线程，可以使用 `类.class` 或 `this` 作为 同步监视器（锁）；

:::

```java
synchronized (同步监视器) {
  // 需要同步的代码
}
```



示例：

:::code-group

```java [继承Thread类] {7}
class window extends Thread {
  private static int tickets = 100;

  @Override
  public void run() {
    while (true) {
      synchronized (window.class) {
        // 同步代码
      }
    }
  }
}
```

```java [实现Runnable接口] {7}
class window1 implements Runnable {
  private int tickets = 100;

  @Override
  public void run() {
    while (true) {
      synchronized (this) {
        // 同步代码
      }
    }
  }
}
```

:::



### 同步方法

:::danger

1. 继承自 `Thread` 的线程，使用同步方法时需要注意，因为默认的同步监视器是 this，当有多个实例时，this 指向会有多个，无法解决线程安全；
2. 当然，如果类内方法允许，可以设置为 `static` 静态的方法；
3. 实现了 `Runnable` 接口的线程，直接使用 同步方法 解决线程安全，因为它的默认同步监视器 `this` 是唯一的；

:::

```java
public synchronized void method() {
  // 方法体
}
```



示例：

::: code-group

```java [实现Runnable接口]
class window2 implements Runnable {
	@Override
  public void run() {
		show();
  }

  /**
   * synchronized 修饰该方法，默认的同步监视器就是 this，它是唯一的
   */
  public synchronized void show() {
  }
}
```

```java [继承Thread类]
class window3 extends Thread {
  @Override
  public void run() {
  }

  /**
   * 不加 static，默认的同步监视器就是this，而这里的this指向的是创建的类的实例，它不唯一
   */
  public static synchronized void show() {
  }
}
```

:::



::: info synchronized的优缺点

优点：

- 使用了同步监视器，确保了线程的安全性。

缺点：

- `synchronized` 在操作数据时，实际上是串行执行的，一个线程修改其他线程只能等待，效率比较低。

::: 





















