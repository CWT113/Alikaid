# 加载三维数据

Cesium 支持大量的数据格式，主要分为一下几类：

- 影像地图：Bing、天地图、ArcGIS、OSM、WMTS、WMS
- 地形数据：ArcGIS、谷歌、STK
- 矢量数据：KML、KMZ、GeoJSON、TopoJSON、CZML
- 三维数据：GLTF、GLB（二进制GLTF文件）
- 三维瓦片：3D Tiles（倾斜摄影、人工模型、三维建筑物、CAD、BIM、点云数据等）



## [影像地图](https://cesium.com/learn/cesiumjs/ref-doc/ImageryLayer.html)

- 加载 [ArcGIS](https://cesium.com/learn/cesiumjs/ref-doc/ArcGisMapServerImageryProvider.html) 在线影像图：

  ```js
  const esri = Cesium.ImageryLayer.fromProviderAsync(
      Cesium.ArcGisMapServerImageryProvider.fromUrl(
          "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
      ),
      {}
  );
  
  const viewer = new Cesium.Viewer("cesiumContainer", {
      baseLayer: esri,
      infoBox: false
  });
  ```

  























## [geojson](https://cesium.com/learn/cesiumjs/ref-doc/GeoJsonDataSource.html?classFilter=GeoJsonDataSource)

::: tip 提示

1.  `Cesium.GeoJsonDataSource.load(linestring)` 的返回值是一个 `Promise` 对象，所以可以使用 `.then` 方法。
2. `viewer.dataSources.add()`可以接收一个 `Promise` 作为参数使用，因此可以将 `load` 方法的返回值作为参数。

:::

### 加载 geojson

1. 加载 turf 生成的线要素：

   ```js
   // 使用 turf 生成一条线
   const lineString = turf.lineString([
       [102.73176821728828, 38.02964680894118],
       [102.73330135753423, 38.02546206796032],
       [102.7356545495424, 38.02598166289124],
       [102.7360289209974, 38.02475990679443]
   ]);
   
   // 方式一
   const promise = Cesium.GeoJsonDataSource.load(lineString, {
       stroke: Cesium.Color.HOTPINK,
       strokeWidth: 5
   });
   promise.then(res => {
       const entity = viewer.entities.add(res.entities.values[0]);
       viewer.zoomTo(entity);
   });
   
   // 方式二(推荐)
   const promise = Cesium.GeoJsonDataSource.load(lineString, {
       stroke: Cesium.Color.HOTPINK,
       strokeWidth: 5
   });
   viewer.dataSources.add(promise);
   viewer.zoomTo(promise);
   ```

   

2. 加载本地 geojson 文件：

   ```js
   import geojson from "../data/geojson.json";
   
   const promise = Cesium.GeoJsonDataSource.load(geojson, {
       markerSize: 40, 							// 点图标大小(像素)
       markerSymbol: "?", 							// 点图标内部的默认符号
       markerColor: Cesium.Color.SKYBLUE, 			// 点图标颜色
       stroke: Cesium.Color.HOTPINK, 				// 线颜色
       strokeWidth: 5, 							// 线宽
       fill: Cesium.Color.SKYBLUE.withAlpha(0.5), 	// 填充颜色
       clampToGround: false 						// 是否贴地(当true时，多边形的外边线将会失效)
   });
   viewer.dataSources.add(promise);
   viewer.zoomTo(promise);
   ```

   

3. 加载 geojson 面要素，并在开启 “贴地” 模式下，加载外边线和中心点图标：

   ```js
   /**
    * @description 加载geojson面数据
    */
   function loadGeojsonData() {
     const promise = Cesium.GeoJsonDataSource.load(geojson, {
       clampToGround: true, // 开启贴地之后，外边线会消失
       fill: Cesium.Color.AZURE.withAlpha(0.5)
     });
     viewer.dataSources.add(promise);
     viewer.zoomTo(promise);
   
     // 重新加载外边线
     const lineArr: any[] = [];
     geojson.features.map(feature => {
       if (feature.geometry && feature.geometry.coordinates) {
         feature.geometry.coordinates.map(coordinate => {
           // turf 把经纬度坐标转为多边形，再转为线要素
           const line = polygonToLine(polygon(coordinate));
           lineArr.push(line);
         });
       }
     });
   
     lineArr.map(line => {
       const outerLine = Cesium.GeoJsonDataSource.load(line, {
         clampToGround: true,
         stroke: Cesium.Color.AQUA,
         strokeWidth: 1
       });
       viewer.dataSources.add(outerLine);
     });
   }
   
   /**
    * @description 加载geojson点数据
    */
   function loadGeojsonPoint() {
     const pointGeoJson: FeatureCollection = {
       type: "FeatureCollection",
       features: []
     };
     geojson.features.map(feature => {
       pointGeoJson.features.push(
         point(feature.properties.center, feature.properties)
       );
       const promise = viewer.dataSources.add(
         Cesium.GeoJsonDataSource.load(pointGeoJson, {})
       );
       promise.then((dataSource: any) => {
         const entities = dataSource.entities.values;
         for (const item in entities) {
           const entity = entities[item];
           // 图标
           entity.billboard = {
             image: "/定位.svg",
             color: Cesium.Color.AQUA,
             width: 25,
             height: 25,
             heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
           };
           // 文字
           entity.label = {
             text: entity.name,
             font: "14px",
             pixelOffset: new Cesium.Cartesian3(0, 30, 0),
             fillColor: Cesium.Color.DARKGREEN
           };
         }
       });
     });
   }
   ```

   

### 删除 geojson

```js {7}
let dataSource: any;
onMounted(() => {
  // ...
  loadGeojsonData();
  setTimeout(() => {
    viewer.dataSources.remove(dataSource);
  }, 3000);
});

/**
 * @description 加载 geojson 数据
 */
async function loadGeojsonData() {
  dataSource = await Cesium.GeoJsonDataSource.load(geojson, {
    clampToGround: true,
    fill: Cesium.Color.AZURE.withAlpha(0.5)
  });
  viewer.dataSources.add(dataSource);
  viewer.zoomTo(dataSource);
}
```



## topojson

topojson 数据的加载方式和 geojson 的加载方式一样，都是使用 `Cesium.GeoJsonDataSource.load()` 方法。

在 Ceisum 官网[下载源代码](https://cesium.com/downloads/)，其中 Cesium-1.99\Apps\SampleData\ne_10m_us_states.topojson ，就是一个 topojson 数据。

```js
const promise = Cesium.GeoJsonDataSource.load(
    "/topojson/ne_10m_us_states.topojson",
    {
        markerSize: 40, 							// 点图标大小(像素)
        markerSymbol: "?", 							// 点图标内部的默认符号
        markerColor: Cesium.Color.SKYBLUE, 			// 点图标颜色
        stroke: Cesium.Color.HOTPINK, 				// 线颜色
        strokeWidth: 5, 							// 线宽
        fill: Cesium.Color.SKYBLUE.withAlpha(0.5), 	// 填充颜色
        clampToGround: false 						// 是否贴地(当true时，多边形的外边线将会失效)
    }
);
viewer.dataSources.add(promise);
viewer.zoomTo(promise);
```



## [kmz / kml](https://cesium.com/learn/cesiumjs/ref-doc/KmlDataSource.html?classFilter=KmlDataSource)

::: tip kmz 和 kml 的区别是什么？

1. `KML`是解压缩文件的文件扩展名，而`KMZ`是`KML`文件的压缩版本；

2. `KML`通常用于保存和存储地图位置，而`KMZ`则以相同的容量用于更具体的位置，例如地标；
3. 与`KMZ`相比，`KML`具有更大的文件空间和更长的数据传输。KMZ作为压缩或压缩文件具有较小的文件空间和大小；
4. `KML`可以被许多运行地图和图像(例如Google Earth和Google Maps)的地理浏览器或程序读取和识别，`KMZ`并不总是这样；

:::

在 Ceisum 官网[下载源代码](https://cesium.com/downloads/)，其中 Cesium-1.99\Apps\SampleData\kml\gdpPerCapita2008.kmz ，就是一个 kmz 数据。

```js
// 加载 kml 只需要换地址即可
const promise = Cesium.KmlDataSource.load("/kmz/gdpPerCapita2008.kmz", {
    camera: viewer.scene.camera,
    canvas: viewer.scene.canvas
});
viewer.dataSources.add(promise);
viewer.zoomTo(promise);
```



## [3D Tiles](https://cesium.com/learn/cesiumjs/ref-doc/Cesium3DTileset.html?classFilter=Cesium3DTileset)

在加载 3D Tiles 数据之前，可以先到 Cesium [官网](https://ion.cesium.com/assets/69380?page=1&sortBy=DATE_ADDED&sortOrder=DESC)添加 墨尔本和纽约 的在线数据。

1. 加载在线数据：

   ```js
   const tileset = viewer.scene.primitives.add(
       // 加载墨尔本建筑物3D Tiles
       await Cesium.Cesium3DTileset.fromIonAssetId(69380),
       // 加载纽约建筑物3D Tiles
       await Cesium.Cesium3DTileset.fromIonAssetId(75343),
       // 加载Google地球3D Tiles
       await Cesium.Cesium3DTileset.fromIonAssetId(2275207)
   );
   ```

2. 加载离线数据，[详见参数配置](https://cesium.com/learn/cesiumjs/ref-doc/Cesium3DTileset.html#.ConstructorOptions)：

   ```js
   const tileset = await Cesium.Cesium3DTileset.fromUrl(
       "/3DTiles/b3dm/tileset.json",
       {
           enableCollision: true,
           skipLevelOfDetail: true,
           baseScreenSpaceError: 1024,
           skipScreenSpaceErrorFactor: 16,
           skipLevels: 1,
           immediatelyLoadDesiredLevelOfDetail: false,
           loadSiblings: false,
           cullWithChildrenBounds: true
       }
   );
   
   viewer.scene.primitives.add(tileset);
   viewer.flyTo(tileset);
   ```

   添加完模型后如果漂浮在空中，可以使用下面的代码调整模型贴地：

   ```js
   // 调整模型的高度偏移
   const heightOffset = -70;
   const boundingSphere = tileset.boundingSphere;
   const cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
   const surface = Cesium.Cartesian3.fromRadians(
       cartographic.longitude,
       cartographic.latitude,
       0.0
   );
   const offset = Cesium.Cartesian3.fromRadians(
       cartographic.longitude,
       cartographic.latitude,
       heightOffset
   );
   const translation = Cesium.Cartesian3.subtract(
       offset,
       surface,
       new Cesium.Cartesian3()
   );
   tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
   ```

   



































